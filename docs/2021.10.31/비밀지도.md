# 2021.10.31 (일요일)
### **1. 비밀지도**

Q. 네오는 평소 프로도가 비상금을 숨겨놓는 장소를 알려줄 비밀지도를 손에 넣었다. 그런데 이 비밀지도는 숫자로 
   암호화되어 있어 위치를 확인하기 위해서는 암호를 해독해야 한다. 다행히 지도 암호를 해독할 방법을 적어놓은 메모도 함께 발견했다.

   1. 지도는 한 변의 길이가 n인 정사각형 배열 형태로, 각 칸은 "공백"(" ") 또는 "벽"("#") 두 종류로 이루어져   
      있다.
   2. 전체 지도는 두 장의 지도를 겹쳐서 얻을 수 있다. 각각 "지도 1"과 "지도 2"라고 하자. 지도 1 또는 지도 2 중 
      어느 하나라도 벽인 부분은 전체 지도에서도 벽이다. 지도 1과 지도 2에서 모두 공백인 부분은 전체 지도에서도 공백이다.
   3. "지도 1"과 "지도 2"는 각각 정수 배열로 암호화되어 있다.
      암호화된 배열은 지도의 각 가로줄에서 벽 부분을 1, 공백 부분을 0으로 부호화했을 때 얻어지는 이진수에 해당하는 값의 배열이다
      
     네오가 프로도의 비상금을 손에 넣을 수 있도록, 비밀지도의 암호를 해독하는 작업을 도와줄 프로그램을 작성하라.
   

#### -  접근방법

1. 문제를 이해하지 못해 시간안에 구현하는 데에 실패하였다.

**<나의풀이>**

```javascript
function solution(n, arr1, arr2) {
  let answer = [];
}
let arr1 = [9, 20, 28, 18, 11];
let arr2 = [30, 1, 21, 17, 28];
console.log(solution(5, arr1, arr2))
```

**<다른 풀이 1번>**
```javascript
function solution(n, arr1, arr2) {
  let answer = [];
  for(let i = 0; i < n; i++) {
    // 입력받은 두 array의 수를 하나씩 가져와서 이진법 변환
    // 0을 채워서 자릿수 맞추기
    const arr1Bin = arr1[i].toString(2).padStart(n,0);
    const arr2Bin = arr2[i].toString(2).padStart(n,0);
    // 만들어진 두 이진수(문자열)을 한글자씩 접근하여 비교하기
    // 둘 중 하나라도 1이면 #(벽), 둘다 0인경우 공백
    // 지도의 한줄
    let mapRow = '';
    for(let j = 0; j < n; j++) {
      if(arr1Bin[j] === '1' || arr2Bin[j] === '1') {
        mapRow += '#';
      } else {
        mapRow += '';
      }
    }
    answer.push(mapRow); 
  }
  return answer;
}
let arr1 = [9, 20, 28, 18, 11];
let arr2 = [30, 1, 21, 17, 28];
console.log(solution(5, arr1, arr2))
```

---
##  **🔥 새로 배운 내용 & 느낀 점**
    
    1. 주어진 두 배열의 요소를 for문으로 각각 접근하여 toString 메소드를 사용하여 문자열 형태인
       이진수로 변환한다.
    2. 그리고 만들어진 이진수의 자릿수를 n만큼 채워야 하므로 padStart 메소드를 사용하여 비어있는 곳을
       0으로 채운다.
    cf. padStart() 메서드는 현재 문자열의 시작을 다른 문자열로 채워, 주어진 길이를 만족하는 
        새로운 문자열을 반환한다. 채워넣기는 대상 문자열의 시작(좌측)부터 적용된다.
    3. 만들어진 이진수를 for문으로 한 글자씩 접근하여 둘 중 하나라도 1이면, 벽이 있는 것이므로 문자열 #을     
       만들어주고 아닌 경우, 공백을 넣어준다.
    4. 가장 상위의 for문의 한 루프가 끝나면 만들어진 행정보를 answer에 push한다.